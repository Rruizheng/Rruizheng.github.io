(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{408:function(s,t,e){"use strict";e.r(t);var v=e(14),_=Object(v.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"css加载会造成阻塞吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css加载会造成阻塞吗"}},[s._v("#")]),s._v(" css加载会造成阻塞吗")]),s._v(" "),t("h3",{attrs:{id:"dom树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dom树"}},[s._v("#")]),s._v(" DOM树")]),s._v(" "),t("ul",[t("li",[s._v("css加载不会阻塞DOM树的解析")]),s._v(" "),t("li",[s._v("css加载会阻塞DOM树的渲染")])]),s._v(" "),t("h3",{attrs:{id:"js执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js执行"}},[s._v("#")]),s._v(" JS执行")]),s._v(" "),t("ul",[t("li",[s._v("js执行会阻塞DOM树的解析和渲染")]),s._v(" "),t("li",[s._v("css加载会阻塞后面js语句的执行")]),s._v(" "),t("li",[s._v("如果js在css后面，就会阻塞DOMContentLoaded")]),s._v(" "),t("li",[s._v("DOMContentLoaded不需要等资源加载，但需要等内置的js执行完毕")]),s._v(" "),t("li",[s._v("浏览器会维持html中css和js的顺序")])]),s._v(" "),t("h3",{attrs:{id:"优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[s._v("#")]),s._v(" 优化")]),s._v(" "),t("ul",[t("li",[s._v("因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:\n"),t("ul",[t("li",[s._v("使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)")]),s._v(" "),t("li",[s._v("对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)")]),s._v(" "),t("li",[s._v("合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)")]),s._v(" "),t("li",[s._v("减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)")])])])]),s._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[s._v("#")]),s._v(" 原理")]),s._v(" "),t("p",[s._v("从上面两个流程图我们可以看出来，浏览器渲染的流程如下：")]),s._v(" "),t("ol",[t("li",[s._v("HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree")]),s._v(" "),t("li",[s._v("将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)")]),s._v(" "),t("li",[s._v("根据Render Tree渲染绘制，将像素渲染到屏幕上。")])]),s._v(" "),t("p",[s._v("从流程我们可以看出来")]),s._v(" "),t("ul",[t("li",[s._v("DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。")]),s._v(" "),t("li",[s._v("然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。")]),s._v(" "),t("li",[s._v("由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。")])]),s._v(" "),t("h3",{attrs:{id:"domcontentloaded"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#domcontentloaded"}},[s._v("#")]),s._v(" DOMContentLoaded")]),s._v(" "),t("ul",[t("li",[s._v("onLoad没什么好说的，就是等待页面的所有资源都加载完成才会触发，这些资源包括css、js、图片视频等。")]),s._v(" "),t("li",[s._v("DOMContentLoaded，当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。")])]),s._v(" "),t("ol",[t("li",[s._v("当页面只存在css，或者js都在css前面，那么DomContentLoaded不需要等到css加载完毕。")]),s._v(" "),t("li",[s._v("当页面里同时存在css和js，并且js在css后面的时候，DomContentLoaded必须等到css和js都加载完毕才触发。")])]),s._v(" "),t("ul",[t("li",[s._v("如果页面中同时存在css和js，并且存在js在css后面，则DOMContentLoaded事件会在css加载完后才执行")]),s._v(" "),t("li",[s._v("其他情况下，DOMContentLoaded都不会等待css加载，并且DOMContentLoaded事件也不会等待图片、视频等其他资源加载。")])])])}),[],!1,null,null,null);t.default=_.exports}}]);